git-sparse-checkout(1)
=======================

NAME
----
git-sparse-checkout - Initialize and modify the sparse-checkout
configuration, which reduces the checkout to a set of directories
given by a list of prefixes.


SYNOPSIS
--------
[verse]
'git sparse-checkout <subcommand> [options]'


DESCRIPTION
-----------

Initialize and modify the sparse-checkout configuration, which reduces
the checkout to a set of directories given by a list of prefixes.


COMMANDS
--------
'list'::
	Provide a list of the contents in the sparse-checkout file.

'init'::
	Enable the `core.sparseCheckout` setting. If the
	sparse-checkout file does not exist, then populate it with
	patterns that match every file in the root directory and
	no other directories, then will remove all directories tracked
	by Git. Add patterns to the sparse-checkout file to
	repopulate the working directory.

'set'::
	Write a set of patterns to the sparse-checkout file, as given as
	a list of arguments following the 'set' subcommand. Update the
	working directory to match the new patterns.

'disable'::
	Remove the sparse-checkout file, set `core.sparseCheckout` to
	`false`, and restore the working directory to include all files.

SPARSE CHECKOUT
----------------

"Sparse checkout" allows populating the working directory sparsely.
It uses the skip-worktree bit (see linkgit:git-update-index[1]) to tell
Git whether a file in the working directory is worth looking at. If
the skip-worktree bit is set, then the file is ignored in the working
directory. Git will not populate the contents of those files, which
makes a sparse checkout helpful when working in a repository with many
files, but only a few are important to the current user.

The `$GIT_DIR/info/sparse-checkout` file is used to define the
skip-worktree reference bitmap. When Git updates the working
directory, it resets the skip-worktree bit in the index based on this
file. If an entry
matches a pattern in this file, skip-worktree will not be set on
that entry. Otherwise, skip-worktree will be set.

Then it compares the new skip-worktree value with the previous one. If
skip-worktree turns from set to unset, it will add the corresponding
file back. If it turns from unset to set, that file will be removed.

To repopulate the working directory with all files, use the
`git sparse-checkout disable` command.

Sparse checkout support in 'git checkout' and similar commands is
disabled by default. You need to set `core.sparseCheckout` to `true`
in order to have sparse checkout support.

## FULL PATTERN SET

By default, the sparse-checkout file uses the same syntax as `.gitignore`
files.

While `$GIT_DIR/info/sparse-checkout` is usually used to specify what
files are included, you can also specify what files are _not_ included,
using negative patterns. For example, to remove the file `unwanted`:

----------------
/*
!unwanted
----------------


## CONE PATTERN SET

The full pattern set allows for arbitrary pattern matches and complicated
inclusion/exclusion rules. These can result in O(N*M) pattern matches when
updating the index, where N is the number of patterns and M is the number
of paths in the index. To combat this performance issue, a more restricted
pattern set is allowed when `core.spareCheckoutCone` is enabled.

The accepted patterns in the cone pattern set are:

1. *Recursive:* All paths inside a directory are included.

2. *Parent:* All files immediately inside a directory are included.

In addition to the above two patterns, we also expect that all files in the
root directory are included. If a recursive pattern is added, then all
leading directories are added as parent patterns.

By default, when running `git sparse-checkout init`, the root directory is
added as a parent pattern. At this point, the sparse-checkout file contains
the following patterns:

```
/*
!/*/*
```

This says "include everything in root, but nothing two levels below root."
If we then add the folder `A/B/C` as a recursive pattern, the folders `A` and
`A/B` are added as parent patterns. The resulting sparse-checkout file is
now

```
/*
!/*/*
/A/*
!/A/*/*
/A/B/*
!/A/B/*/*
/A/B/C/*
```

Here, order matters, so the negative patterns are overridden by the positive
patterns that appear lower in the file.

If `core.sparseCheckoutCone=true`, then Git will parse the sparse-checkout file
expecting patterns of these types. Git will warn if the patterns do not match.
If the patterns do match the expected format, then Git will use faster hash-
based algorithms to compute inclusion in the sparse-checkout.

SEE ALSO
--------

linkgit:git-read-tree[1]
linkgit:gitignore[5]

GIT
---
Part of the linkgit:git[1] suite
